let _ = GMain.init ()

(*------------------------------ 80 caracters --------------------------------*)

(*
#directory "+lablGL";;
#directory "+sdl";;
#load "lablgl.cma";;
#load "bigarray.cma";;
#load "sdl.cma";;
#load "str.cma";;
*)

let fontName = "/usr/share/fonts/truetype/msttcorefonts/Arial.ttf";;
let xrot = ref 0.0 and yrot = ref 0.0 and zrot = ref 0.0;;
let xpos = ref 0.0 and ypos = ref 0.0 and zpos = ref 0.0;;
let zoom = ref 1.0;;

(* Parses vertex found in the input OBJ file *)
let rec captureVertices inputFile = 
  try
    match Str.split (Str.regexp_string " ") (input_line inputFile) with
      | ["v"; x; y; z] ->
	((float_of_string x),
	 (float_of_string y),
	 (float_of_string z))::(captureVertices inputFile);
      | _ -> captureVertices inputFile;
  with End_of_file -> close_in inputFile; [];
;;

(* Converts 
   ["1"; "3"; "2"] 
and 
   [(x1, y1, z1); (x2, y2, z2); (x3, y3, z3); ...] 
to 
   [(x1, y1, z1); (x3, y3, z3); (x2, y2, z2)]  *)
let rec ftoString indexList vertices =
  match indexList with
    | [] -> []
    | e::l -> (List.nth vertices ((int_of_string e)-1))::(ftoString l vertices)
;;

(* Parses faces found in the input OBJ file *)
let rec captureFaces inputFile vertices = 
  try
    match Str.split (Str.regexp_string " ") (input_line inputFile) with
      | e::l when e = "f" -> 
	  (List.length l, ftoString l vertices)::(captureFaces inputFile vertices);
      | _ -> captureFaces inputFile vertices;
  with End_of_file -> close_in inputFile; [];
;;

(* Create a new compatible 3D object from an OBJ file
   Syntax is :
   [ (3, [(x1, y1, z1); (x2, y2, z2); (x3, y3, z3)]);
   (npoints, [ list of points (3D coordinates) ]);
   ... ]
*)
let rec obj_to_3D objfile =
  try
    captureFaces (open_in objfile) (captureVertices (open_in objfile));  
  with Sys_error e -> 
    print_endline e;
    let newfile = "test.obj" in
    if objfile <> newfile then 
      begin
	print_endline "loading default file";
	obj_to_3D newfile;
      end
    else
      [];   
;;

let rec drawFace = function
  | [] -> ();
  | (x, y, z)::l -> 
      let c = (y+.1.0)/.2.0 in
	GlDraw.color (1., c, c);
	GlDraw.vertex3 (x, y, z);
	drawFace l;
;;

let rec drawModel model =
  match model with
    | [] -> ();
    | (n, face)::tail -> 
	begin
	  GlDraw.polygon_mode `both `fill;
	  match n with
	    | 3 -> GlDraw.begins `triangles;
	    | 4 -> GlDraw.begins `quads;
	    | _ -> GlDraw.begins `polygon;
	end;
	drawFace face;
	GlDraw.ends ();
	drawModel tail;
;;

(* Display scene and fill screen *)
let drawScene screen model =
  GlMat.mode `projection;
  GlMat.load_identity ();

  GlMat.ortho 
    ~x:(-1.5 *. !zoom, 1.5 *. !zoom) 
    ~y:(-1.5 *. !zoom, 1.5 *. !zoom) 
    ~z:(-3.5 *. !zoom, 3.5 *. !zoom);
  GlMat.mode `modelview;
  GlMat.load_identity (); 
  GlClear.clear [ `color;`depth];

  GlMat.translate ~x:!xpos ~y:!ypos ~z:!zpos ();
  GlMat.rotate ~angle:!xrot ~x:1. ();
  GlMat.rotate ~angle:!yrot ~y:1. ();

  GlMat.scale ~x:0.5 ~y:0.5 ~z:0.5 ();

  drawModel model;

  Gl.flush ();
  Sdlgl.swap_buffers ();
;;

(* Here we handle all events *)
let rec mainLoop screen model =
  drawScene screen model;
  match Sdlevent.wait_event () with
    | Sdlevent.KEYDOWN {Sdlevent.keysym=Sdlkey.KEY_ESCAPE}
    | Sdlevent.QUIT -> Sdl.quit ();
    | event -> begin match event with
	| Sdlevent.MOUSEMOTION e 
	    when e.Sdlevent.mme_state = [Sdlmouse.BUTTON_RIGHT] ->
	  xrot := !xrot +. float e.Sdlevent.mme_yrel;
	  yrot := !yrot +. float e.Sdlevent.mme_xrel;
	| Sdlevent.MOUSEMOTION e 
	    when e.Sdlevent.mme_state = [Sdlmouse.BUTTON_LEFT] ->
	  xpos := !xpos +. float e.Sdlevent.mme_xrel /. 150.0 *. !zoom;
	  ypos := !ypos -. float e.Sdlevent.mme_yrel /. 150.0 *. !zoom;
	| Sdlevent.MOUSEBUTTONDOWN b 
	    when b.Sdlevent.mbe_button = Sdlmouse.BUTTON_WHEELDOWN ->
	  zoom := !zoom *. 1.1;
	| Sdlevent.MOUSEBUTTONDOWN b 
	    when b.Sdlevent.mbe_button = Sdlmouse.BUTTON_WHEELUP ->
	  zoom := !zoom /. 1.1;
	| event -> ();
	 (* print_endline (Sdlevent.string_of_event event);*)
    end;
      mainLoop screen model;
;;

(* Setup the screen *)
let glscreen () =
  Sdl.init [`EVERYTHING];
(*  Sdlttf.init ();*)
  Sdlwm.set_caption ~title:"AutoMap" ~icon:"";
  let screen = Sdlvideo.set_video_mode 500 500 [`OPENGL; `DOUBLEBUF] in
 (* 
  let text = "Lo.." in
  let font = Sdlttf.open_font fontName 24 in
  let loading = Sdlttf.render_text_blended font "Lol" ~fg:Sdlvideo.red in
  let loadingPos = Sdlvideo.rect 0 0 500 500 in
  Sdlvideo.blit_surface ~dst_rect:loadingPos ~src:loading ~dst:screen ();
  Sdlvideo.flip screen;
  Sdlvideo.update_rect screen;
*)
  let model = obj_to_3D "test.obj" in
  (*Gl.enable `cull_face;*)
  Gl.enable `depth_test;
  GlFunc.depth_mask true;
  GlFunc.depth_range ~near:0.1 ~far:10.0;

(*
  Gl.enable `lighting;
  Gl.enable `light0;
  GlLight.light ~num:0 (`position (1., -1., 1., 1.));
  GlLight.material `both (`shininess 100.);
  Gl.enable `color_material;
  GlLight.color_material `both `specular;
  GlLight.color_material `both `ambient_and_diffuse;
*)  

  mainLoop screen model;

(*  Sdlttf.quit ();*)
   Sdl.quit ();
;;

let contour image  =
  let x, y, z = Sdlvideo.surface_dims image in
    for i = 0 to x-1 do
      for j = 0 to y-1 do
	if ((Sdlvideo.get_pixel_color image i j) <> (Sdlvideo.get_pixel_color image (i+1) j)) then
          Sdlvideo.put_pixel_color image i j Sdlvideo.black;  
	if ((Sdlvideo.get_pixel_color image i j) <>  (Sdlvideo.get_pixel_color image i (j+1) )) then
          Sdlvideo.put_pixel_color image i j Sdlvideo.black;
      done;
      done
	
let rec sdlInit image  =
  Sdl.init [`VIDEO];
  let (w, h, p) = Sdlvideo.surface_dims image in
  let screen = Sdlvideo.set_video_mode w h [`DOUBLEBUF] in
  let position = Sdlvideo.rect 0 0 w h in
    Sdlvideo.blit_surface ~dst_rect:position ~src:image ~dst:screen ();
    Sdlvideo.flip screen 
	   
let printContour image =
  contour image

let printQuad image h =
  let a, b, c = Sdlvideo.surface_dims image in
    for y=0 to (b/h)-1 do
      for x=0 to (a/h)-1 do
	for i=0 to h do
	  Sdlvideo.put_pixel_color image ((x*h)+i) (y*h) Sdlvideo.black;
	  Sdlvideo.put_pixel_color image (x*h) ((y*h)+i) Sdlvideo.black;
	  Sdlvideo.put_pixel_color image ((x*h)+i) ((y*h)+i) Sdlvideo.black;
	  Sdlvideo.put_pixel_color image ((x*h)+i) ((y*h)+h-i) Sdlvideo.black;
	done;
      done;
    done
    
let write_vertex x y z file =
  output_string file ("v " ^ 
			(string_of_float x) ^ " " ^
			(string_of_float y) ^ " " ^
			(string_of_float z) ^ "\n")

let write_face v1 v2 v3 file =
  output_string file ("f " ^
			(string_of_int v1) ^ " " ^
			(string_of_int v2) ^ " " ^
			(string_of_int v3) ^ "\n")

let trace_points hp w h outputFile =
  let file = open_out outputFile in 
    for y=0 to (h/hp) do
      for x=0 to (w/hp) do
	write_vertex (float (x*hp)) (float (y*hp)) 0. file;
      done;
    done;
    for y=0 to (h/hp)-1 do
      for x=0 to (w/hp)-1 do
	write_vertex 
	  (float (x*hp) +. float hp /. 2.)
	  (float (y*hp) +. float hp /. 2.)
	  0. file;
      done;
    done;
    let n = (w/hp) in
      for y=0 to n do
	for x=0 to n do
	  write_face (2*y*(n-1)+x-y+1) (2*y*(n-1)+x-y+2)
	    ((2*y+1)*(n-1)+x-y+1) file;
	  write_face ((2*y+2)*(n-1)+x-y) ((2*y+2)*(n-1)+x-y+1)
	    ((2*y+1)*(n-1)+x-y+1) file;
	  write_face (2*y*(n-1)+x-y+1) ((2*y+1)*(n-1)+x-y+1)
	    ((2*y+2)*(n-1)+x-y) file;
	  write_face (2*y*(n-1)+x-y+2) ((2*y+1)*(n-1)+x-y+1)
	    ((2*y+2)*(n-1)+x-y+1) file;
	done;
      done;
      close_out file

let printImage image =
  sdlInit image
    
let save image =
  Sdlvideo.save_BMP image "resultat.bmp"
    
let get_string = function 
  | Some x -> x
  | _ -> raise Not_found

let window = GWindow.window
  ~resizable:false
  ~title:"AutoMap"
  ~width:800
  ~height:600 ()

let vbox = GPack.vbox
  ~border_width:15
  ~packing:window#add ()

let bbox = GPack.button_box `HORIZONTAL
  ~layout:`SPREAD
  ~packing:(vbox#pack ~expand:false) ()

let pic_borderline = GButton.button
  ~label:"Contours"
  ~packing:bbox#add ()

let pic_cut = GButton.button
  ~label:"Quadrillage"
  ~packing:bbox#add ()

let pic_3d = GButton.button
  ~label:"Relief"
  ~packing:bbox#add ()

let open_pic = GFile.chooser_button
    ~action:`OPEN
    ~packing:bbox#add ()

let save_pic = GButton.button
  ~label:"Sauvegarder"
  ~packing:bbox#add ()

let image_pic = GMisc.image
    ~packing:vbox#add ()

let generate_obj w h =
  trace_points 20 w h "test.obj"
          
let sdlLaunch openpic picborder picquad savepic pic3d () = 
  let path = get_string openpic#filename in
  let image = Sdlloader.load_image path in
    image_pic#set_file path;
    picborder#connect#clicked ~callback:(fun _ -> printContour image;
					   save image;
					   image_pic#set_file
					     "resultat.bmp");
    picquad#connect#clicked ~callback:(fun _ -> printQuad image 20;
					 save image;
					 image_pic#set_file "resultat.bmp"); 
    savepic#connect#clicked ~callback:(fun _ -> save image);
    pic3d#connect#clicked ~callback:(fun _ -> let (w, h, _) =
				       Sdlvideo.surface_dims image in
				       generate_obj w h;
				       glscreen ());
    ()

let _ =
  window#connect#destroy ~callback:GMain.quit;
  open_pic#connect#selection_changed (sdlLaunch open_pic pic_borderline pic_cut
					save_pic pic_3d);
  window#show ();
  GMain.main ()
